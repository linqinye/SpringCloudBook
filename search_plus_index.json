{"./":{"url":"./","title":"前言","keywords":"","body":"Spring Cloud学习笔记 By Dazzle Lin            updated 2019-07-02 22:33:38 "},"Chapter1/Spring Cloud Eureka.html":{"url":"Chapter1/Spring Cloud Eureka.html","title":"Spring Cloud Eureka","keywords":"","body":"Spring Cloud Eureka 产生背景 服务治理可以说是微服务架构中最为核心和基础的模块， 它主要用来实现各个微服务实例的自动化注册与发现。随着业务的发展， 系统功能越来越复杂， 相应的微服务应用也不断增加， 我们的静态配置就会变得越来越难以维护。 并且面对不断发展的业务， 我们的集群规模、 服务的位置 、 服务的命名等都有可能发生变化， 如果还是通过手工维护的方式， 那么极易发生错误或是命名冲突等问题。 同时， 对于这类静态内容的维护也必将消耗大量的人力。为了解决微服务架构中的服务实例维护问题， 产生了大量的服务治理框架和产品 服务治理的基本概念 服务注册：在服务治理框架中， 通常都会构建 一 个注册中心， 每个服务单元向注册中心登记自己提供的服务， 将主机与端口号、 版本号、 通信协议等一些附加信息告知注册中心， 注册中心按服务名分类组织服务清单。 服务发现：由于在服务治理框架下运作， 服务间的调用不再通过指定具体的实例地址来实现， 而是通过向服务名发起请求调用实现。 所以， 服务调用方在调用服务提供方接口的时候， 并不知道具体的服务实例位置。 因此， 调用方需要向服务注册中心咨询服务， 并获取所有服务的实例清单， 以实现对具体服务实例的访问。 Netflix Eureka Spring Cloud Eureka, 使用Netflix Eureka来实现服务注册与发现， 它既包含了服务端组件，也包含了客户端组件，并且服务端与客户端均采用Java编写，所以Eureka主要适用于通过Java实现的分布式系统，或是与JVM兼容语言构建的系统。但是， 由于Eureka服务端的服务治理机制提供了完备的RESTful API，所以它也支持将非Java语言构建的微服务应用纳入Eureka的服务治理体系中来。只是在使用其他语言平台的时候，需要自己来实现Eureka的客户端程序。不过庆幸的是，在目前几个较为流行的开发平台上，都已经有了一 些针对Eureka 注册中心的客户端实现框架. Eureka服务端，我们也称为服务注册中心。它同其他服务注册中心 一 样，支持高可用配置。它依托于强 一 致性提供良好的服务实例可用性，可以应对多种不同的故障场景。如果Eureka以集群模式部署，当集群中有分片出现故障时，那么Eureka就转入自我保护模式。它允许在分片故障期间继续提供服务的发现和注册，当故障分片恢复运行时，集群中的其他分片会把它们的状态再次同步回来。以在AWS 上的实践为例，Netflix推荐每个可用的区域运行 一 个Eureka服务端，通过它来形成集群。不同可用区域的服务注册中心通过异步模式互相复制各自的状态，这意味着在任意给定的时间点每个实例关于所有服务的状态是有细微差别的。 Eureka客户端，主要处理服务的注册与发现。客户端服务通过注解和参数配置的方式，嵌入在客户端应用程序的代码中，在应用程序运行时，Eureka客户端向注册中心注册自身提供的服务并周期性地发送心跳来更新它的服务租约。同时，它也能从服务端查询当前注册的服务信息并把它们缓存到本地并周期性地刷新服务状态。 搭建服务注册中心 org.springframework.boot spring-boot-starter-parent 2.1.3.RELEASE org.springframework.cloud spring-cloud-starter-netflix-eureka-server 通过 @EnableEurekaServer 注解启动 一 个服务注册中心提供给其他应用进行对话 @EnableEurekaServer @SpringBootApplication public class EurekaServerApplication { public static void main(String[] args) { SpringApplication.run(EurekaServerApplication.class, args); } } 在默认设置下， 该服务注册中心也会将自己作为客户端来尝试注册自己，所以我们需要禁用它的客户端注册行为 server.port=8080 spring.application.name=eureka-server eureka.instance.hostname=localhost eureka.client.register-with-eureka=false eureka.client.fetch-registry=false eureka.client.serviceUrl.defaultZone=http://${eureka.instance.hostname}:${server.port}/eureka/ eureka.client.register-with-eureka: 由于该应用为注册中心，所以设置为 false, 代表不向注册中心注册自己。 eureka.client.fetch-registry: 由于注册中心的职责就是维护服务实例，它并不需要去检索服务， 所以也设置为 false 访问 http://localhost: 8080/ 注册服务提供者 org.springframework.cloud spring-cloud-starter-netflix-eureka-client 在主类中通过加上 @EnableEurekaClient 注解， 激活 Eureka 中的DiscoveryClient 实现（自动化配置， 创建 DiscoveryClient 接口针对 Eureka 客户端的 EurekaDiscoveryClient 实例） @EnableEurekaClient @SpringBootApplication @RestController public class HelloServerApplication { @RequestMapping(\"/\") public String home() { return \"Hello world\"; } public static void main(String[] args) { SpringApplication.run(HelloServerApplication.class, args); } } 在 配置文件中， 通过 spring.application.name属性来为服务命名， 比如命名为 hello-service。 再通过eureka.client.serviceUrl.defaultZone属性来指定服务注册中心的地址， 这里我们指定为之前构建的服务注册中心地址 server.port=9090 spring.application.name=hello-service eureka.client.serviceUrl.defaultZone=http://127.0.0.1:8080/eureka/ 在服务注册中心的控制台中，可以看到类似下面的输出，名为hello-service的服务被注册成功了 高可用注册中心 Eurek a Server的高可用实际上就是将自己作为服务向其他服务注册中心注册自己， 这样就可以形成 一 组互相注册的服务注册中心， 以实现服务清单的互相同步， 达到高可用的效果。 application-peer1.properties server.port=8080 spring.application.name=eureka-server eureka.instance.hostname=peer1 eureka.client.serviceUrl.defaultZone=http://peer2:8081/eureka/ application-peer2.properties server.port=8081 spring.application.name=eureka-server eureka.instance.hostname=peer2 eureka.client.serviceUrl.defaultZone=http://peer1:8080/eureka/ 在etc/hosts文件中添加对peer1 和 peer2的转换， 让上面配置的host形式的serviceUrl能在本地正确访间到； Windows系统路径为C:\\Windows\\System32\\drivers\\etc\\hosts。 127.0.0.1 peer1 127.0.0.1 peer2 通过spring.profiles.active属性来分别启动peer1和peer2 java -jar eureka-server-0.0.1-SNAPSHOT.jar --spring.profiles.active = peerl java -jar eureka-server-0.0.1-SNAPSHOT.jar --spring.profiles.active = peer2 修改hello-service eureka.client.serviceUrl.defaultZone=http://127.0.0.1:11112/eureka/,http://127.0.0.1:11111/eureka/ 如我们不想使用主机名来定义注册中心的地址，也可以使用IP地址的形式，但是需要在配置文件中增加配置参数eureka.instance.prefer-ip-address = true, 该值默认为false 服务发现与消费 服务消费者主要完成两个目标，发现服务以及消费服务 。 其中，服务发现的任务由Eureka的客户端完成，而服务消费的任务由Ribbon完成 。 Ribbon是一个基于HTTP和TCP的客户端负载均衡器，它可以在通过客户端中配置的 ribbonServerList服务端列表去轮询访问以达到均衡负载的作用。 当Ribbon与Eureka联合使用时，Ribbon的服务实例清单RibbonServerList会被DiscoveryEnabledNIWSServerList重写， 扩展成从Eureka注册中心中获取服务端列表。 同时它也会用 NIWSDiscoveryPing来取代IPing, 它将职责委托给Eureka 来确定服务端是否已经启动。它在Eureka服务发现的基础上，实现了一套对服务实例的选择策略，从而实现对服务的消费。 1.为了实验Ribbon的客户端负载均衡功能， 我们通过 java-jar命令行的方式来启动两个不同端口的hello-service 2.创建 一 个 Spring Boot 的基础工程来实现服务消费者， 取名为 ribbon-consumer，导入 spring-cloud-starter-ribbon依赖 3.创建应用主类 ConsumerApplication, 通过 @EnableDiscoveryClient注解让该应用注册为 Eureka 客户端应用， 以获得服务发现的能力。 同时， 在该主类中创建 RestTemplate 的 Spring Bean 实例，并通过 @LoadBalanced 注解开启客户端负载均衡 4.创建ConsumerController类并实现／ribbon-consumer接口。 在该接口中，通过在上面创建的RestTemplate 来实现对 HELLO -SERVICE服务提供的/hello接口进行调用。 可以看到这里访问的地址是服务名HELLO-SERVICE, 而不是一个具体的地址。在服务治理框架中，这是一个非常重要的特性。 5.在application.properties中配置Eureka服务注册中心的位置, 需要与之前的HELLO-SERVICE一样，不然是发现不了该服务的，同时设置该消费者的端口不能与之前启动的应用端口冲突. 6.通过向 http://localhost:9000/ribbon-consumer 发起 GET 请求， 成功返回了 \"Hello World\" 。 此时， 我们可以在 ribbon-consumer 应用的控制台中看到Ribbon输出了当前客户端维护的 HELLO-SERVICE 的服务列表情况。其中包含了各个实例的位置,Ribbon就是按照此信息进行轮询访问，以实现基于客户端的负载均衡。 另外还输出了 一 些其他非常有用的信息， 如对各个实例的请求总数量、第一 次连接信息、上一次连接信息、总的请求失败数量等 7.再尝试发送几次请求， 并观察启动的两个 HELLO-SERVICE 的控制台， 可以看到两个控制台会交替打印日志， 这是我们之前在 HelloController 中实现的对服务信息的输出， 可以用来判断当前Ribbon-consumer 对 HELLO-SERVICE 的调用是否是负载均衡的。 Eureka详解 基础架构 Eureka服务治理体系的三个核心角色： 服务注册中心： Eureka提供的服务端， 提供服务注册与发现的功能。 服务提供者：提供服务的应用， 可以是 Spring Boot 应用， 也可以是其他技术平台且遵循 Eureka通信机制的应用。它将自己提供的服务注册到 Eureka, 以供其他应用发现。 服务消费者：消费者应用从服务注册中心获取服务列表， 从而使消费者可以知道去何处调用其所需要的服务，包括Feign的消费。 很多时候， 客户端既是服务提供者也是服务消费者。 服务治理机制 \"服务注册中心-1\" 和“ 服务注册中心-2\", 它们互相注册组成了高可用集群。 \"服务提供者”启动了两个实例，一个注册到 “ 服务注册中心-1\"上，另外一个注册到“ 服务注册中心-2\" 上。 还有两个“ 服务消费者 “ ，它们也都分别只指向了一个注册中心。 服务提供者 服务注册：“服务提供者”在启动的时候会通过发送REST请求的方式将自己注册到EurekaServer上， 同时带上了自身服务的 一 些元数据信息。Eureka Server接收到这个REST请求之后，将元数据信息存储在一个双层结构Map中， 其中第一层的key是服务名， 第二层的key是具体服务的实例名。 在服务注册时， 需要确认 一 下 eureka.client.register-with-eureka = true参数是否正确， 该值默认为true。 若设置为false将不会启动注册操作。 服务同步：如架构图中所示， 这里的两个服务提供者分别注册到了两个不同的服务注册中心上，也就是说，它们的信息分别被两个服务注册中心所维护。 此时， 由于服务注册中心之间因互相注册为服务， 当服务提供者发送注册请求到 一 个服务注册中心时， 它会将该请求转发给集群中相连的其他注册中心，从而实现注册中心之间的服务同步 。 通过服务同步，两个服务提供者的服务信息就可以通过这两台服务注册中心中的任意 一 台获取到。 服务续约：在注册完服务之后，服务提供者会维护一个心跳用来持续告诉EurekaSe1-ver: \"我还活着” ， 以防Eureka Server的 “剔除任务”将该服务实例从服务列表中排除出去，我们称该操作为服务续约(Renew) 服务续约有两个重要属性： eureka.instance.lease-renewal-interval-in-seconds=30 定义服务续约任务的调用间隔时间，默认为30秒. eureka.instance.lease-expiration-duration-in-seconds=90 定义服务失效的时间，默认为90秒. 服务消费者 获取服务：当我们启动服务消费者的时候，它会发送一个REST请求给服务注册中心，来获取上面注册的服务清单 。为了性能考虑，EurekaServer会维护 一 份只读的服务清单来返回给客户端，同时该缓存清单会每隔30秒更新一 次。 获取服务是服务消费者的基础 eureka.client.fetch-registry=true 该值默认为true。 若希望修改缓存清单的更新时间 eureka.client.registry-fetch-interval-seconds = 30 该参数默认值为30, 单位为秒. ​ 服务调用：服务消费者在获取服务清单后，通过服务名可以获得具体提供服务的实例名和该实例的元数据信息。 因为有这些服务实例的详细信息， 所以客户端可以根据自己的需要决定具体调用哪个实例，在Ribbon中会默认采用轮询的方式进行调用，从而实现客户端的负载均衡. ​ 对于访问实例的选择，Eureka中有Region和Zone的概念，一个Region中可以包含多个Zone, 每个服务客户端需要被注册到一个Zone中， 所以每个客户端对应一个Region和一个Zone。 在进行服务调用的时候，优先访问同处一个Zone中的服务提供方， 若访问不到，就访问其他的Zone。 ​ 服务下线：在系统运行过程中必然会面临关闭或重启服务的某个实例的情况， 在服务关闭期间，我们自然不希望客户端会继续调用关闭了的实例。 所以在客户端程序中， 当服务实例进行正常的关闭操作时， 它会触发一个服务下线的REST请求给Eureka Server, 告诉服务注册中心：“我要下线了” 。 服务端在接收到请求之后， 将该服务状态置为下线(DOWN), 并把该下线事件传播出去。 服务注册中心 失效剔除：有些时候， 我们的服务实例并不一定会正常下线， 可能由于内存溢出、 网络故障等原因使得服务不能正常工作， 而服务注册中心并未收到“ 服务下线 ”的请求。 为了从服务列表中将这些无法提供服务的实例剔除， EurekaServer在启动的时候会创建 一 个定时任务，默认每隔一 段时间（默认为60秒）将当前清单中超时（默认为90秒）没有续约的服务剔除出去。 自我保护:当我们在本地调试基于Eureka的程序时，基本上都会碰到这样一个问题， 在服务注册中心的信息面板中出现类似下面的红色警告信息: 实际上， 该警告就是触发了EurekaServer的自我保护机制。 之前我们介绍过， 服务注册到EurekaServer之后，会维护一个心跳连接，告诉EurekaServer自己还活着。EurekaServer在运行期间，会统计心跳失败的比例在15分钟之内是否低于85%, 如果出现低于的情况（在单机调试的时候很容易满足， 实际在生产环境上通常是由于网络不稳定导致）， EurekaServer会将当前的实例注册信息保护起来， 让这些实例不会过期， 尽可能保护这些注册信息。 但是， 在这段保护期间内实例若出现问题， 那么客户端很容易拿到实际已经不存在的服务实例， 会出现调用失败的清况， 所以客户端必须要有容错机制， 比如可以使用请求重试、 断路器等机制。 由于本地调试很容易触发注册中心的保护机制， 这会使得注册中心维护的服务实例不那么准确。 所以， 我们在本地进行开发的时候，可以使用eureka.server.enable­self-preservation= false参数来关闭保护机制， 以确保注册中心可以将不可用的实例正确剔除。 配置详解 在Eureka的服务治理体系中， 主要分为服务端与客户端两个不同的角色， 服务端为服务注册中心， 而客户端为各个提供接口的微服务应用。 当我们构建了高可用的注册中心之后， 该集群中所有的微服务应用和基础类应用（如配置中心、 API网关等）都可以视作该体系下的一个微服务(Eureka客户端）。服务注册中心也 一 样， 只是高可用环境下的服务注册中心除了作为客户端之外， 还为集群中的其他客户端提供了服务注册的特殊功能。 Eureka客户端的配置主要分为以下两个方面： 服务注册相关的配置信息， 包括服务注册中心的地址、 服务获取的间隔时间、 可用区域等。 服务实例相关的配置信息， 包括服务实例的名称、IP地址、 端口号、 健康检查路径等。 服务注册类配置 配置信息都以 eureka.client 为前缀 指定注册中心 为了服务注册中心的安全考虑， 很多时候我们都会为服务注册中心加入安全校验。 这个时候， 在配置 serviceUrl 时， 需要在 value 值的 URL 中加入相应的安全校验信息， 比如 http://:@localhost:1111/eureka 。 其中， 为安全校验信息的用户名， 为该用户的密码. 其他配置 | 参数名 | 说明 | 默认值 | | --------------------------------------------- | ------------------------------------------------------------ | ------ | | enabled | 启用Eureka客户端 | true | | registryFetchIntervalSeconds | 从Eureka服务端获取注册信息的间隔时间，单位为秒 | 30 | | instancelnfoReplicationlntervalSeconds | 更新实例信息的变化到E田eka服务端的间隔时间， 单位为秒 | 30 | | initialInstanceInfoReplicationIntervalSeconds | 初始化 实例信息到Eureka服务端的间隔时 间，单位为秒 | 40 | | eurekaServiceUrlPollIntervalSeconds | 轮询Eureka服务端地址更改的间隔时间， 单位为秒。 当我们与Spring Cloud Config配合，动态刷新Eureka的serv1ceURL地址时需要关注该参数 | 300 | | eurekaServerReadTimeoutSeconds | 读取Eureka Se1-ver信息的超时时间， 单位为秒 | 8 | | eurekaServerConnectTimeoutSeconds | 连接 Eureka Server的超时时间， 单位为秒 | 5 | 服务实例类配置 元数据 Eureka客户端在向服务注册中心发送注册请求时,用来描述自身服务信息的对象，其中包含了一些标准化的元数据，比如服务名称、实例名称、实例IP、实例端口等用于服务治理的重要信息；以及一些用于负载均衡策略或是其他特殊用途的自定义元数据信息。 在使用 Spring Cloud Eureka的时候，所有的配置信息都通过org.springframework.cloud.netflix.eureka.EurekalnstanceConfigBean进行加载，但在真正进行服务注册的时候，还是会包装成com.netflix.appinfo.Instancelnfo 对象发送给Eureka服务端 。我们可以直接查看 com.netflix.appinfo.Instancelnfo类中的详细定义来了解原生Eureka对元数据的定义。 其中， Map metadata= new ConcurrentHashMap ()是自定义的元数据信息， 而其他成员变量则是标准化的元数据信息。 我们可以通过 eureka.instance.=的格式对标准化 元数据直接进行配置,其中就是 EurekainstanceConfigBean对象 中的成员变量名 。而对于自定义元数据，可以通过 eureka.instance.metadataMap.=的格式来进行配置，比如： eureka.instance.metadataMap.zone=shanghai 实例名配置 实例名，即InstanceInfo 中的instanceId参数， 它是区分同一服务中不同实例的唯一标识。在NetflixEureka的原生实现中，实例名采用主机名作为默认值， 这样的设置使得在同一主机上无法启动多个相同的服务实例。所以， 在Spring Cloud Eureka的配置中，针对同一主机中启动多实例的情况，对实例名的默认命名做了更为合理的扩展， 它采用了如下默认规则： ${spring.cloud.client.hostname}:${spring.application.name}:${spring.application .instance—id:$ {server.port}} 对千实例名的命名规则，我们可以通过eureka.instance.instanceId参数来进行配置。 比如， 在本地进行客户端负载均衡调试时，需要启动同一服务的多个实例，如果我们直接启动同一个应用必然会产生端口冲突。 虽然可以在命令行中指定不同的server.port 来启动， 但是这样还是略显麻烦。 实际上，我们可以直接通过设置 server.part=0 或者使用随机数 server.port=${randorn.int[10000,19999]} 来让Tomcat 启动的时候采用随机端口。但是这个时候我们会发现注册到 Eureka Server 的实例名都是相同的， 这会使得只有一个服务实例能够正常提供服务。 对于这个问题， 我们就可以通过设置实例名规则来轻松解决： eureka.instance.instanceid=${spring.application.name}:${random.int}} 利用应用名加随机数的方式来区分不同的实例，从而实现在同一主机上，不指定端口就能轻松启动多个实例的效果。 端点配置 在 Instanceinfo 中， 我们可以看到 一 些 URL 的配置信息， 比如 homePageUrl、statusPageUrl、healthCheckUrl, 它们分别代表了应用主页的 URL、状态页的 URL、健康检查的 URL 。 其中，状态页和健康检查的URL在Spring Cloud Eureka 中默认使用了spring-boot-actuator 模块提供的 /info 端点和 /health 端点。 为了服务的正常运作， 我们必须确保Eureka 客户端的 /health 端点在发送元数据的时候， 是一个能够被注册中心访问到的地址， 否则服务注册中心不会根据应用的健康检查来更改状态（仅当开启了 healthcheck 功能时， 以该端点信息作为健康检查标准）。 而/info 端点如果不正确的话，会导致在 Eureka 面板中单击服务实例时，无法访问到服务实例提供的信息接口。 大多数情况下，我们并不需要修改这几个 URL 的配置，但是在 一 些特殊情况下，比如，为应用设置了 context-path, 这时， 所有 spring-boot-actuator 模块的监控端点都会增加一个前缀。 management.context-path=/hello eureka.instance.statusPageUrlPath=${management.context-path}/info eureka.instance.healthCheckUrlPath=${management.context-path}/health 为了安全考虑， 也有可能会修改 /info 和 /health 端点的原始路径 endpoints.info.path=/appinfo endpoints.health.path=/checkHealth eureka.instance.statusPageOrlPath=/${endpoints.info.path} eureka.instance.healthCheckOrlPath=/${endpoints.health.path} 上述两个配置值有一个共同特点，它们都使用相对路径来进行配置 。由千Eureka的服务注册中心默认会以HTTP的方式来访问和暴露这些端点，因此当客户端应用以HTTPS的方式来 暴露服务和监控端点时，相对路径的配置方式就无法满足需求了。所以，Spring Cloud Eureka还提供了绝对路径的配置参数 eureka.instance.statusPageUrl=https://${eureka.instance.hostname}/info eureka.instance.healthCheckUrl=https://${eureka.instance.hostname}/health eureka.instance.homePageUrl=https://${eureka.instance.hostname}/ 健康检测 默认情况下，Eureka中各个服务实例的健康检测并不是通过spring-boot-actuator模块的/health 端点来实现的， 而是依靠客户端心跳的方式来保持服务实例的存活。 在Eureka 的服务续约与剔除机制下， 客户端的健康状态从注册到注册中心开始都会处于UP状态， 除非心跳终止 一 段时间之后，服务注册中心将其剔除。 默认的心跳实现方式可以有效检查客户端进程是否正常运作,但却无法保证客户端应用能够正常提供服务 。由于大多数微服务应用都会有 一 些其他的外部资源依赖， 比如数据库、 缓存、 消息代理等，如果我们的应用与这些外部资源无法联通的时候， 实际上已经不能提供正常的对外服务了， 但是因为客户端心跳依然在运行，所以它还是会被服务消费者调用， 而这样的调用实际上并不能获得预期的结果. 通过简单的配置， 把Eureka客户端的健康检测交给spring-boot-actuator模块的/health端点， 以实现更加全面的健康状态维护。 在pom.xml中引入spring-boot-starter-actuator模块的依赖。 在application.properties中增加参数配置 eureka.client.healthcheck.enabled=true。 如果客户端的/health端点路径做了一些特殊处理，请参考前文介绍端点配置时的方法进行配置， 让服务注册中心可以正确访问到健康检测端点。 其他配置 参数均以 eureka.instance为前缀 | 参数名 | 说明 | 默认值 | | -------------------------------- | ------------------------------------------------------------ | ------ | | preferIpAddress | 是否优先使用IP地址作为主机名的标识 | false | | leaseRenewalIntervalInSeconds | Eureka客户端向服务端发送心跳的时间间隔， 单位为秒 | 30 | | leaseExpirationDurationInSeconds | Eureka服务端在收到最后一 次心跳之后等待的时间上限，单位为秒。 超过该时间之后服务端会将该服务实例从服务消单中剔除， 从而禁止服务调用请求被发送到该实例上 | 90 | | nonSecurePort | 非安全的通信端口号 | 80 | | securePort | 安全的通信端口号 | 443 | | nonSecurePortEnabled | 是否启用非安全的通信端口号 | true | | securePortEnabled | 是否启用安全的通信端口号 | | | hostname | 主机名， 不配置的时候将根据操作系统的主机名来获取 | | | appname | 服务名，默认取spring.application.name的配置值，如果没有则为unknown | | 跨平台支持 By Dazzle Lin            updated 2019-07-02 22:46:26 "},"Chapter2/Spring cloud Ribbon.html":{"url":"Chapter2/Spring cloud Ribbon.html","title":"Spring cloud Ribbon","keywords":"","body":"Spring cloud Ribbon Spring Cloud Ribbon 是一个基于HTTP和TCP的客户端负载均衡工具,它基于 Netflix Ribbon实现。通过 Spring Cloud 的封装，可以让我们轻松地将面向服务的 REST 模板请求自动转换成客户端负载均衡的服务调用。Spring Cloud Ribbon 虽然只是一个工具类框架，它不像服务注册中心、配置中心、API 网关那样需要独立部署，但是它几乎存在于每一个Spring Cloud构建的微服务和基础设施中。因为微服务间的调用，API 网关的请求转发等内容实际上都是通过Ribbon 来实现的，包括后续我们将要介绍的 Feign, 它也是基于 Ribbon实现的工具。 所以，对Spring Cloud Ribbon的理解和使用,对于我们使用 Spring Cloud 来构建微服务非常重要。 客户端负载均衡 客户端负载均衡和服务端负载均衡最大的不同点在于上面所提到的服务清单所存储的位置。 在客户端负载均衡中， 所有客户端节点都维护着自己要访问的服务端清单， 而这些服务端的清单来自于服务注册中心。 同服务端负载均衡的架构类似， 在客户端负载均衡中也需要心跳去维护服务端清单的健康性， 只是这个步骤 需要与服务注册中心配合完成。 RestTemplate 详解 RestTemplat对象会使用 Ribbon 的自动化配置， 同时通过配置 @LoadBalanced 还能够开启客户端负载均衡。 Get请求 一：getForEntity 函数 该方法返回的是 ResponseEntity, 该对象是 Spring对 HTTP 请求响应的封装， 其中主要存储了 HTTP 的几个重要元素， 比如 HTTP 请求状态码的枚举对象 HttpStatus (也就是我们常说的 404 、500 这些错误码）、 在它的父类 HttpEntity 中还存储着 HTTP 请求的头信息对象 HttpHeaders 以及泛型类型的请求体对象。 RestTemplate restTemplate=new RestTemplate(); ResponseEntity responseEntity=restTemplate.getForEntity(\"http://USER-SERVICE/user?name={1}\", String.class, \"didi\"); String body = responseEntity.getBody(); getForEntity函数实际上提供了以下三种不同的重载实现: getForEntity(String url, Class responseType, Object ... urlVariables) 该方法提供了三个参数， 其中 url 为请求的地址， responseType 为请求响应体body 的包装类型，urlVariables 为 url 中的参数绑定。 getForEntity(String url, Class responseType, Map urlVariables) 这里使用了 Map 类型， 所以使用该方法进行参数绑定时需要在占位符中指定 Map 中参数的 key 值 RestTemplate restTemplate = new RestTemplate(); Map params = new HashMap<>(); params.put(\"name\", \"dada\"); ResponseEntity responseEntity = restTemplate.getForEntity(\"http://USER-SERVICE/user?name={name}\", String.class, params); getForEntity(URI url, Class responseType) 该方法使用 URI 对象来替代之前的 url 和 urlVariables 参数来指定访问地址和参数绑定。 URI 是 JDKjava.net 包下的一个类，它表示一个统一资源标识符 (Uniform Resource Identifier)引用。 RestTemplate restTemplate = new RestTemplate(); UriComponents uriComponents = UriComponentsBuilder.fromUriString( \"http://USER-SERVICE/user?name={name}\") .build() .expand (\"dodo\") .encode(); URI uri=uriComponents.toUri(); ResponseEntity responseEntity = restTemplate.getForEntity(uri,String.class).getBody(); 二：getForObject 函数 该方法可以理解为对 getForEntity 的进 一 步封装，它通过 HttpMessageConverterExtractor 对 HTTP 的请求响应体 body 内容进行对象转换， 实现请求直接返回包装好的对象内容。 RestTemplate restTemplate=new RestTemplate(); User result=restTemplate.getForObject(uri,User.class); 当不需要关注请求响应除 body 外的其他内容时， 该函数就非常好用， 可以少一个从Response 中获取 body 的步骤。 它与 getForEntity 函数类似， 也提供了三种不同的重载实现。 getForObject (String url, Class responseType, Object. .. urlVariables) 与 getForEntity 的方法类似， url 参数指定访问的地址， responseType 参数定义该方法的返回类型， urlVariables 参数为 url 中占位符对应的参数。 getForObject(String url, Class responseType, Map urlVariables) 在该函数中，使用 Map 类型的 urlVariables 替代上面数组形式的 urlVariables,因此使用时在 url 中需要将占位符的名称与 Map 类型中的 key一一对应设置。 getForObject(URI url, Class responseType) 该方法使用 URI 对象来替代之前的 url和urlVariables 参数使用。 POST请求 一：postForEntity 函数 RestTemplate restTemplate = new RestTemplate(); User user=new User(\"didi\",30); ResponseEntity responseEntity=restTemplate.postForEntity(\"http://USER-SERVICE/user\", user, String.class); String body=responseEntity.getBody(); postForEntity(String url, Objec七 request, Class responseType,Object ... uri Variables) postForEntity(String url, Object request, Class responseType,Map uri Variables) postForEntity(URI url, Object request,Class responseType) 这里需要注意的是新增加的request参数， 该参数可以是一个普通对象， 也可以是一个HttpEntity对象。 如果是 一个普通对象， 而非HttpEntity对象的时候， RestTempla七e会将请求对象转换为一个HttpEntity对象来处理， 其中Object就是request的类型， request内容会被视作完整的body来处理；而如果request是一个HttpEntity对象， 那么就会被当作一个完成的HTTP请求对象来处理， 这个request中不仅包含了body的内容， 也包含header的内容。 二：postForObject函数 作用是简化postForEntity的后续处理。 通过直接将请求响应的body内容包装成对象来返回使用 RestTemplate rest Template=new RestTemplate(); User user= new User(\"didi\", 20); String postResult = restTemplate.postForObject(\"http://USER-SERVICE/user\", user,String.class); postForObject(String url, Object request, Class responseType,Object ... uri Variables) postForObject(String url, Object request, Class responseType,Map uriVariables) postForObject(URI url, Object reques七， Class responseType) 三：postForLocation函数 该方法实现了以POST请求提交资源， 并返回新资源的URI。 User user= new User(\"didi\", 40); URI responseURI = restTemplate.postForLocation(\"http:/ /USER-SERVICE/user\", user); postForLocation (String url, Object request, Object ... url Variables) postForLocation(String url, Object request， Map urlVariables) postForLocation(URI url, Object request) 由于 postForLocation函数会返回新资源的URI, 该URI就相当于指定了返回类型，所以此方法实现的POST请求不需要像postForEntity和postForObject那样指定responseType。 PUT请求 RestTemplate restTemplate=new RestTemplate(); Long id=100011; User user=new User(\"didi\", 40); restTemplate.put(\"http://USER-SERVICE/user/{l}\", user, id); put(String url, Object request, Object ... urlVariables) put(String url, Object request, Map urlVariables) put(URI url, Object request) DELETE请求 RestTemplate restTemplate = new RestTemplate(); Long id= 10001L; restTemplate.delete(\"http://USER-SERVICE/user/{1)\", id); delete(String url, Object ... urlVariables) delete(String url, Map urlVariables) delete(URI url) DELETE请求也不需要request的body信息,url指定DELETE请求的位置， urlVariables绑定url中的参数 By Dazzle Lin            updated 2019-07-02 22:40:05 "},"Chapter3/Spring Cloud Hystrix.html":{"url":"Chapter3/Spring Cloud Hystrix.html","title":"Spring Cloud Hystrix","keywords":"","body":"Spring Cloud Hystrix 在微服务架构中， 我们将系统拆分成了很多服务单元， 各单元的应用间通过服务注册与订阅的方式互相依赖。 由于每个单元都在不同的进程中运行， 依赖通过远程调用的方式执行， 这样就有可能因为网络原因或是依赖服务自身间题出现调用故障或延迟，而这些问题会直接导致调用方的对外服务也出现延迟， 若此时调用方的请求不断增加，最后就会因等待出现故障的依赖方响应形成任务积压，最终导致自身服务的瘫痪。 快速入门 启动工程如下 eureka-server:服务注册中心，端口11112 hello-server:服务单元，启动两个实例8081/8082 ribbon-consume:使用ribbon实现的消费者，端口9000 未加入断路器之前，关闭8081，发送GET消费，获得如下输出 下面开始引入hystrix 在ribbon-consume的pom.xml加入依赖 org.springframework.cloud spring-cloud-starter-netflix-hystrix 工程主类加入@EnableCircuitBreaker注解开启断路器功能 注意：这里还可以使用 Spring Cloud 应用中的 @SpringCloudApplication 注解来修饰应用主类， 该注解的具体定义如下所示。 可以看到， 该注解中包含了上述我们所引用的三个注解， 这也意味着—个Spring Cloud 标准应用应包含服务发现以及断路器。 @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @SpringBootApplication @EnableDiscoveryClient @EnableCircuitBreaker public @interface SpringCloudApplication { } 改造服务消费方式 新增 HelloService 类， 注入 RestTemplate 实例。 然后，将在 ConsumerController 中对 RestTemplate 的使用迁移到 helloService函数中，最后，在 helloService 函数上增加 @HystrixCommand注解来指定回调方法。 @Service public class helloService { @Autowired RestTemplate restTemplate; @HystrixCommand(fallbackMethod = \"helloFaceback\") public String helloConsumer(){ return restTemplate.getForEntity(\"http://HELLOSERVICE/hello\",String.class).getBody(); } public String helloFaceback(){ return \"error\"; } } 修改controller,注入实例并调用 @Autowired private helloService helloService; @RequestMapping(value = \"/ribbon-consumer\",method = RequestMethod.GET) public String helloService(){ return helloService.helloConsumer(); } 验证结果 我们来验证一下通过断路器实现的服务回调逻辑，重新启动之前关闭的8081端口的Hello-Service, 确保此时服务注册中心、 两个 Hello-Service 以及 RIBBON­CONSUMER 均已启动，访问 http://localhost:9000/ribbon-consumer 可以轮询两个 HELLO-SERV工CE 并返回一些文字信息 此时我们继续断开8081的HELLO-SERVICE,然后访问 http://localhost:9000/ribbon-consumer, 当轮询到 8081 服务端时，输出内容为 error, 不再是之前的错误内容， Hystrix 的服务回调生效。 除了通过断开具体的服务实例来模拟某个节点无法访问的情况之外，我们还可以模拟 一 下服务阻塞（长时间未响应）的情况。 我们对 HELLO-SERVICE 的 /hello 接口做 一 些修改，具体如下: @RequestMapping(value = \"/hello\",method = RequestMethod.GET) public String index() throws InterruptedException { for(String s:client.getServices()){ List instances=client.getInstances(s); //让线程等待几秒 int sleepTime=new Random().nextInt(3000); logger.info(\"sleepTime:\" + sleepTime); Thread.sleep(sleepTime); for(ServiceInstance instance:instances){ logger.info( \"/hello, host:\" + instance.getHost() + \", service_id:\" + instance.getServiceId()); } } return \"Hello World\"; } 通过 Thread. sleep ()函数可让 /hello 接口的处理线程不是马上返回内容，而是在阻塞几秒之后才返回内容。 由于 Hystrix 默认超时时间为 1000 毫秒，所以这里采用了 0至3000 的随机数以让处理过程有 一 定概率发生超时来触发断路器。 为了更精准地观察断路器的触发，在消费者调用函数中做一些时间记录，具体如下： @HystrixCommand(fallbackMethod = \"helloFaceback\",commandKey = \"helloKey\") public String helloConsumer(){ long start = System.currentTimeMillis(); String result=restTemplate.getForEntity(\"http://HELLO-SERVICE/hello\",String.class).getBody(); long end= System.currentTimeMillis(); logger.info(\"Spend time : \"+ (end - start)); return result.toString(); } 重新启动HELLO-SERVICE和RIBBON-CONSUMER的实例，连续访问http://localhost:9000/ribbon-consumer几次，我们可以观察到，当RIBBON-CONSUMER的控制台中输出的Spend time大于2000的时候，就会返回error, 即服务消费者因调用的服务超时从而触发熔断请求，并调用回调逻辑返回结果。 参数配置对应类：HystrixCommandProperties @HystrixCommand(fallbackMethod = \"helloFaceback\",commandProperties = {@HystrixProperty(name = \"execution.isolation.thread.timeoutInMilliseconds\",value = \"2000\")}) Hystrix仪表盘 创建一个标准的 Spring Boot 工程， 命名为 hystrix-dashboard 。 编辑 pom.xml, 具体依赖内容如下所示： org.springframework.boot spring-boot-starter-actuator org.springframework.cloud spring-cloud-starter-netflix-hystrix org.springframework.cloud spring-cloud-starter-netflix-hystrix-dashboard org.springframework.boot spring-boot-starter-test test 为应用主类加上 @EnableHystrixDashboard, 启用 Hystrix Dashboard 功能 根据实际情况修改application.properties 配置文件 spring.application.name=hystrix-dashboard server.port=9001 修改ribbon-consumer的pom org.springframework.boot spring-boot-starter-actuator 启动类加上 @EnableCircuitBreaker @EnableHystrix @EnableHystrixDashboard @Bean public ServletRegistrationBean getServlet(){ HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet(); ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet); registrationBean.setLoadOnStartup(1); registrationBean.addUrlMappings(\"/actuator/hystrix.stream\"); registrationBean.setName(\"HystrixMetricsStreamServlet\"); return registrationBean; } By Dazzle Lin            updated 2019-07-02 22:47:59 "},"Chapter4/Spring Cloud Feign.html":{"url":"Chapter4/Spring Cloud Feign.html","title":"Spring Cloud Feign","keywords":"","body":"Spring Cloud Feign 基于 Netflix Feign 实现，整合了 Spring Cloud Ribbon 与 Spring Cloud Hystrix, 除了提供这两者的强大功能之外，它还提供了 一 种声明式的 Web 服务客户端定义方式。 创建一个接口并用注解的方式来配置它， 即可完成对服务提供方的接口绑定，简化了在使用 Spring Cloud Ribbon 时自行封装服务调用客户端的开发量。 Spring Cloud Feign 具备可插拔的注解支持，包括 Feign 注解和 JAX-RS 注解。 同时，为了适应 Spring 的广大用户，它在 Netflix Feign的基础上扩展了对 Spring MVC 的注解支待。 快速入门 1.创建 一 个 Spring Boot 基础工程， 取名为 feign-consumer, 并在 pom.xml中引入 spring-cloud-starter-eureka和spring-cloud-starter-feign依赖。 2.启动类注解开启 @EnableFeignClients @EnableDiscoveryClient 3.定义 HelloService 接口， 通过 @FeignClient 注解指定服务名来绑定服务， 然后再使用 Spring MVC 的注解来绑定具体该服务提供的 REST 接口。 @FeignClient(\"HELLO-SERVICE\") public interface HelloService { @RequestMapping(value = \"/hello\") String hello(); } 注意：这里服务名不区分大小写， 所以使用 hello-service和HELLO-SERVICE 都是可以的。 另外， 在 Brixton.SR5 版本中， 原有的 serviceld 属性已经被废弃，若要写属性名， 可以使用 name或value 。 4.创建一个 ConsumerController 来实现对 Feign 客户端的调用。使用@Autowired直接注入上面定义的 HelloService 实例，并在 helloConsumer函数中调用这个绑定了 hello-service 服务接口的客户端来向该服务发起 /hello 接口的调用。 @RestController public class ConsumerController { @Autowired private HelloService helloService; @RequestMapping(method = RequestMethod.GET,value = \"/feign-consumer\") public String helloConsumer(){ return helloService.hello(); } } 5.修改配置application.properties spring.application.name=feign-consumer server.port=9001 eureka.client.serviceUrl.defaultZone = http://localhost:11112/eureka/ 6.访问http://localhost:9001/feign-consumer @RestController public class ConsumerController { @Autowired private HelloService helloService; @RequestMapping(method = RequestMethod.GET,value = \"/feign-consumer\") public String helloConsumer(){ return helloService.hello(); } } By Dazzle Lin            updated 2019-07-02 22:48:50 "},"Chapter5/Spring Cloud Zuul.html":{"url":"Chapter5/Spring Cloud Zuul.html","title":"Spring Cloud Zuul","keywords":"","body":"Spring Cloud Zuul(API网关) 快速入门 1.api-gateway org.springframework.cloud spring-cloud-starter-netflix-zuul zuul包含下列依赖： spring-cloud-starter-hystrix： 该依赖用来在网关服务中实现对微服务转发时候的保护机制，通过线程隔离和断路器，防止微服务的故障引发API网关资源无法释放， 从而影响其他应用的对外服务。 spring-cloud-starter-Ribbon: 该依赖用来实现在网关服务进行路由转发时候的客户端负载均衡以及请求重试。 spring-boot-starter-actuator: 该依赖用来提供常规的微服务管理端点。 另外， 在Spring Cloud Zuul中还特别提供了/routes端点来返回当前的所有路由规则。 2.@EnableZuulProxy注解开启Zuul的API网关服务功能 3.application.properties中配置Zuul应用的基础信息 spring.application.name = api-gateway server.port = 5555 请求路由 为了与Eureka整合， 我们需要在 api-gateway 的 pom.xml 中引入spring­cloud-starter-eureka依赖 在api-gateway的application.properties 配置文件中指定Eureka注册中心的位置， 并且配置服务路由. zuul.routes.api-a.path=/api-a/** zuul.routes.api-a.serviceId=hello-service zuul.routes.api-b.path=/api-b/** zuul.routes.api-b.serviceId=feign-consumer eureka.client.serviceUrl.defaultZone=http://localhost:11112/eureka/ 通过上面的搭建工作， 我们已经可以通过服务网关来访问 hello-service 和feign-consumer这两个服务 了。 根据配置的映射关系， 分别向网关发 起下面这些请求。 • http://localhost:5555/api-a/hello: 该 url符合/api-a/规则， 由api-a路由负责转发，该路由映射的serviceId为hello-service, 所以最终/hello请求会被发送到hello-service服务的 某个 实例上去。 • http://localhost:5555/api-b/feign-consumer: 该url符合/api-b/规则，由 api-b路由负责转发，该路由映射的serviceId为feign-consumer,所以最终/feign-consumer请求会被发送到feign-consumer服务的某个实例上去. 请求过滤 剥离出校验逻辑，构建独立的鉴权服务 前置网关完成非业务性质的校验 在请求到达的时候就完成校验和过滤，而不是转发后再过滤而导致更长的请求延迟 通过在网关中完成校验和过滤， 微服务应用端就可以去除各种复杂的过滤器和拦截器了 Zuul 允许开发者在API网关上通过定义过滤器来实现对请求的拦截与过滤，实现的方法非常简单，我们只需要继承 ZuulFilter抽象类并实现它定义的4个抽象函数就可以完成对请求的拦截和过滤了. 实现了在请求被路由之前检查HttpServletRequet中是否有 accessToken 参数， 若有就进行路由， 若没有就拒绝访问， 返回 401 Unauthorized 错误 @Slf4j public class AccessFilter extends ZuulFilter { @Override public String filterType() { return \"pre\"; } @Override public int filterOrder() { return 0; } @Override public boolean shouldFilter() { return true; } @Override public Object run() throws ZuulException { RequestContext ctx = RequestContext.getCurrentContext(); HttpServletRequest request = ctx.getRequest(); log.info(\"send {} request to{}\", request.getMethod () , request.getRequestURL().toString()); Object accessToken = request.getParameter(\"accessToken\"); if(accessToken == null) { log.warn(\"access token is empty\"); ctx.setSendZuulResponse(false); ctx.setResponseStatusCode(401); return null; } log.info(\"access token ok\"); return null; } } 在上面实现的过滤器代码中，我们通过继承ZuulFilter抽象类并重写下面4个方法来实现自定义的过滤器。 这4个方法分别定义了如下内容。 FilterType: 过滤器的类型， 它决定过滤器在请求的哪个生命周期中执行。 这里定义为pre, 代表会在请求被路由之前执行。 FilterOrder: 过滤器的执行顺序。 当请求在一个阶段中存在多个过滤器时，需要根据该方法返回的值来依次执行。 shouldFilter: 判断该过滤器是否需要被执行。 这里我们直接返回了true, 因此该过滤器对所有请求都会生效。 实际运用中我们可以利用该函数来指定过滤器的有效范围。 run: 过滤器的具体逻辑。 这里我们通过ctx.setSendZuulResponse(false)令zuul过滤该请求， 不对其进行路由， 然后通过 ctx.setResponseStatus­Code (401)设置了其返回的错误码，当然也可以进一步优化我们的返回，比如，通过ctx.setResponseBody(body)对返回的body内容进行编辑等. 实现了自定义过滤器之后， 它并不会直接生效， 我们还需要为其创建具体的Bean才能启动该过滤器， 比如， 在应用主类中增加如下内容 @SpringBootApplication @EnableZuulProxy @EnableDiscoveryClient public class ApiGatewayApplication { public static void main(String[] args) { SpringApplication.run(ApiGatewayApplication.class, args); } @Bean public AccessFilter accessFilter(){ return new AccessFilter(); } } 在对api-gateway服务完成了上面的改造之后， 我们可以重新启动它， 并发起下面的请求， 对上面定义的过滤器做 一 个验证。 • http://localhost:5555/api-a/hello: 返回401错误。 • http://localhost:5555/api-a/hello&accessToken = token: 正确路由到hello-service的/hello接口， 并返回Hello World。 总结 它作为系统的统一入口，屏蔽了系统内部各个微服务的细节。 它可以与服务治理框架结合，实现自动化的服务实例维护以及负载均衡的路由转发。 它可以实现接口权限校验与微服务业务逻辑的解耦。 通过服务网关中的过炖器， 在各生命周期中去校验请求的内容， 将原本在对外服务层做的校验前移， 保证了微服务的无状态性， 同时降低了微服务的测试难度， 让服务本身更集中关注业务逻辑的处理 路由详解 传统路由方式 单实例配置 zuul.routes.api-a-url.path=/api-a-url/** zuul.routes.api-a-url.url=http://localhost:8080/ 该配置定义了发往API网关服务的请求中， 所有符合/api-a-url/**规则的访问都将被路由转发到http://localhost:8080/地址上，也就是 说，当我们访问http://localhost:5555/api-a-url/hello的时候，API网关服务会将该请求路由到http://localhost:8080/hello提供的微服务接口上。 其中 ，配置属性zuul.routes.api-a-url.path 中的api-a-url部分为路由的名字，可以任意定义，但是一组path和url映射关系的路由名要相同，面向服务的映射方式也是如此。 多实例配置 zuul.routes.user-service.path = /user-service/** zuul.routes.user-service.serviceid=user-service ribbon.eureka.enabled = false user-service.ribbon.listOfServers = http://localhost:8080/,http://localhost:8081/ 该 配 置 实 现了对 符 合 /user-service/** 规 则 的 请 求 路 径 转 发 到http://localhost:8080/和http://localhost:8081/两个实例地址的路由规则。 它的配置方式与服务路由的配置 方式一 样，都采用了zuul.routes. .path与zuul.routes. .serviceId参数对的映射方式，只是这里的 serviceid 是由用户手工命名 的服务名称 ，配 合ribbon.listOfServers 参数实现服务与实例的维护。由于存在多个实例，API网关在进行路由转发时需要实现负载均衡策略，于是这里还需要Spring Cloud Ribbon的配合。由千在Spring Cloud Zuul中自带了对Ribbon的依赖， 所以我们只需做 一 些配置即可。 ribbon.eureka.enabled:由于zuul.routes. .serviceid指定的是服务名称，默认清况下Ribbon会根据服务发现机制来获取配置服务名对应的实例清单。 但是，该示例并没有整合类似Eureka之类的服务治理框架，所以需要将该参数设置为false, 否则配置的serviceId获取不到对应实例的清单. user-service.ribbon.listOfServers: 该 参数内容与 zuul.routes..serviceid 的配置相对 应， 开头的 user-service 对应了serviceId的值， 这两个参数的配置相当于在该应用内部手工维护了服务与实例的对应关系. 不论是单实例还是多实例的配置方式，我们都需要为每一对映射关系指定一个名称，也就是上面配置中的 , 每一个对应了一条路由规则。 每条路由规则都需要通过 path 属性来定义一个用来匹配客户端请求的路径表达式， 并通过 url 或serviceId属性来指定请求表达式映射具体实例地址或服务名。 面向服务的路由 传统路由运维修改配置麻烦，可以让路由的path不是映射具体的url, 而是让它映射到某个具体的服务 ，而具体的url则交给Eureka的服务发现机制去自动维护，我们称这类路由为面向服务的路由。 zuul.routes..path与zuul.routes..serviceid参数对的方式进行配置, 其中可以指定为任意的路由名称 zuul.routes.user-service.path=/user-service/** zuul.routes.user-service.serviceid=user-service 对千面向服务的路由配置，更简洁的配置方式：zuul.routes.=, 其中用来指定路由的具体服务名，用来配置匹配的请求表达式 zuul.routes.user-service=/user-service/** 当采用path与serviceId以服务路由的方式实现时，在没有配置任何实例地址的情况下，外部请求经过API网关的时候， 它是如何被解析并转发到服务具体实例的呢？ 答 Zuul巧妙地整合了Eureka 来实现面向服务的路由。实际上，我们可以直接将API网关也看作Eureka服务治理下的 一个普通微服务应用。 它除了会将自己注册到Eureka服务注册中心上之外，也会从注册中心获取所有服务以及它们的实例清单。所以，在Eureka的帮助下，API网关服务本身就已经维护了系统中所有 serviceId与实例地址的映射关系。当有外部请求到达 API 网关的时候，根据请求的URL路径找到最佳匹配的path规则， API 网关就可以知道要将该请求路由到哪个具体的serviceId上去。由于在 API 网关中已经知道serviceid对应服务实例的地址清单，那么只需要通过Ribbon的负载均衡策略，直接在这些清单中选择一个具体的实例进行转发就能完成路由工作了. 服务路由的默认规则 对于具有规则性的配置内容， 我们总是希望可以自动化地完成。 非常庆幸，Zuul默认实现了这样的贴心功能， 当我们为Spring Cloud Zuul构建的 API 网关服务引入Spring Cloud Eureka之后， 它为Eureka中的每个服务都自动创建一个默认路由规则， 这些默认规则的path会使用serviceId配置的服务名作为请求前缀。 由千默认情况下所有Eureka上的服务都会被Zuul自动地创建映射关系来进行路由，这会使得 一 些我们不希望对外开放的服务也可能被外部访问到。 这个时候， 我们可以使用zuul.ignored-services参数来设置一个服务名匹配表达式来定义不自动创建路由的规则。 Zuul在自动创建服务路由的时候会根据该表达式来进行判断， 如果服务名匹配表达式 ， 那 么 Zuul 将跳过该服 务 ，不为其创建路由规则 。比如，设 置 为zuul.ignored-services=*的时候，Zuul将对所有的服务都不自动创建路由规则。 在这种情况下，我们就要在配置文件中逐个为需要路由的服务添加映射规则（可以使用path与 serviceId组合的配置方式， 也可使用更简洁的 zuul.routes.=配置方式），只有在配置文件中出现的映射规则会被创建路由，而从Eureka中获取的其他服务，Zuul将不会再为它们创建路由规则。 自定义路由映射规则 我们在构建微服务系统进行业务逻辑开发的时候， 为了兼容外部不同版本的客户端程序（尽量不强迫用户升级客户端），一 般都会采用开闭原则来进行设计与开发。这使得系统在迭代过程中，有时候会需要我们为一组互相配合的微服务定义一个版本标识来方便管理它们的版本关系，根据这个标识我们可以很容易地知道这些服务需要一起启动并配合使用。比如可以采 用 类 似这 样 的 命 名：userservice-vl 、userservice-v2、orderservice-vl、orderservice-v2。默认情况下，Zuul自动为服务创建的路由表达式会采用服务名作为前缀， 比如针对上面的userservice-vl 和userservice-v2,它会产生/userservice-vl 和/userservice-v2两个路径表达式来映射，但是这样生 成出来的表达式规则较为单 一 ，不利于通过路径规则来进行管理。 通常的做法是为这些不同版 本的 微 服 务 应 用 生 成以版 本代号 作 为 路 由 前 缀 定 义 的 路 由 规 则 ， 比如/vl/userservice/ 。 这时候， 通过这样具有版本号前缀的 URL 路径，我们就可以很容易地通过路径表达式来归类和管理这些具有版本信息的微服务了。 对上面所述的需求，如果我们的各个微服务应用都遵循了类似userservice-vl这样的命名规则，通过－分隔的规范来定义服务名和服务版本标识的话，那么，我们可以使用Zuul中自定义服务与路由映射 关系的功能，来实现为符合上述规则的微服务自动化地创建类似/vl/userservice/** 的路由匹配规则。 实现步骤非常简单， 只需在 API 网关程序中， 增加如下Bean的创建即可： @Bean public PatternServiceRouteMapper serviceRouteMapper () { return new PatternServiceRouteMapper( \"(?^.+)-(?v.+$)\", \"${version}/${name}\"); } PatternServiceRouteMapper对象可以让开发者通过正则表达式来自定义服务与路由映射的生成关系。 其中构造函数的第一个参数是用来匹配服务名称是否符合该自定义规则的正则表达式， 而第二个参数则是定义根据服务名中定义的内容转换出的路径表达式规则。当开发者在 API 网关中定义了PatternServiceRouteMapper 实现之后，只要符合第一个参数定义规则的服务名， 都会优先使用该实现构建出的路径表达式，如果没有匹配上的服务则还是会使用默认的路由映射规则，即采用完整服务名作为前缀的路径表达式。 路径匹配 在Zuul中，路由匹配的路径表达式采用了Ant风格定义。 Ant风格的路径表达式使用起来非常简单，它 一 共有下面这三种通配符。 ？ 匹配任意单 个字符 * 匹配任意数朵的字符 ** 匹配任意数址的字符， 支待多级目录 当我们使用通配符的时候，经常会碰到这样的问题：一个URL 路径可能会被多个不同路由的表达式匹配上。 比如，有这样一个场景，我们在系统建设的一开始实现了user-service 服务 zuul.routes.user-service.path=/user-service/** zuul.routes.user-service.serviceid=user-service 随着版本的迭代， 我们对 user-service 服务做了一些功能拆分， 将原属于user-service 服务的某些功能拆分到了另外 一 个全新的服务 user-service-ext 中去，而这些拆分的外部调用 URL 路径希望能够符合规则 /userservice/ext/**, 这个时候我们需要就在配置文件中增加一个路由规则 zuul.routes.user-service.path=/user-service/** zuul.routes.user-service.serviceid=user-service zuul.routes.user-service-ex七.path=/user-service/ext/** zuul.routes.user-service-ext.serviceid=user-service-ext 此时， 调用 user-service-ext服务的 URL 路径实际上会同时被 /user­service/ 和 /user-service/ext/ 两个表达式所匹配。 在逻辑上， API 网关服务需要优先选择 /user-service/ext/ 路由，然后再匹配 /user-service/ 路由才能实现上述需求。但是如果使用上面的配置方式，实际上是无法保证这样的路由优先顺序的。 下面的路由匹配算法中， 我们可以看到它在使用路由规则匹配请求路径的时候是通过线性遍历的方式，在请求路径获取到第 一 个匹配的路由规则之后就返回并结束匹配过程。所以当存在多个匹配的路由规则时， 匹配结果完全取决于路由规则的保存顺序。 @Override public Route getMatchingRoute{final String path) { ZuulRoute route= null; if (!matchesignoredPatterns(adjustedPath)) { for (Entry entry : this. routes. get () . entrySet ()) { String pattern= entry. getKey () ; log.debug(\"Matching pat七ern:\" + pattern); if (this.pathMatcher.match(pattern, adjustedPa七h)) { route = entry.getValue(); break; } } log.debug(\"route matched=\" + route); return getRoute(route, adjustedPath); } 下面所示的代码是基础的路由规则加载算法， 我们可以看到这些路由规则是通过LinkedHashMap保存的， 也就是说， 路由规则的保存是有序的， 而内容的加载是通过遍历配置文件中路由规则依次加入的，所以导致问题的根本原因是对配置文件中内容的读取。 protected Map locateRoutes() { LinkedHashMap routesMap = new LinkedHashMap(); for (ZuulRoute route : this.properties.getRoutes() .values()) { routesMap.put(route.getPath(), route); } return routesMap; } 由千properties的配置内容无法保证有序，所以当出现这种情况的时候， 为了保证路由的优先顺序， 我们需要使用YAML文件来配置， 以实现有序的路由规则， 比如使用下面的定义 zuul: routes: user-service-ext: path: /user-service/ext/** serviceld: user-service-ext user-service: path: /user-service/** serviceld: user-service 忽略表达式 通过 path 参数定义的 Ant 表达式已经能够完成 API 网关上的路由规则配置功能，但是为了更细粒度和更为灵活地配置路由规则， Zuul 还提供了一个忽略表达式参数zuul.ignored-patterns 。 该参数可以用来设置不希望被 API 网关进行路由的 URL 表达式。该参数在使用时还需要注意它的范围并不是对某个路由， 而是对所有路由。 所 以在设置的时候需要全面考虑 URL 规则， 防止忽略了不该被忽略的 URL 路径 不希望 /hello 接口被路由 zuul.ignored-patterns = /**/hello/** zuul.routes.api-a.path=/api-a/** zuul.routes.api-a.serviceid=hello-service 通过网关来访间 hello-service 的 /hello 接口 http://localhost:5555/api-a/hello 。 虽然该访问路径完全符合 path 参数定义的/api-a/** 规则，但是由于该路径符合 zuul.ignored-patterns 参数定义的规则，所以不会被正确路由。 同时，我们在控制台或日志中还能看到没有匹配路由的输出信息 o.s.c.n.z.f.pre.PreDecorationFilter : No route found for uri: /api-a/hello\\ 路由前缀 方便全局地为路由规则增加前缀信息， Zuul 提供了 zuul.prefix 参数来进行设置。比如，希望为网关上的路由规则都增加 /api 前缀，那么我们可以在配置文件中增加配置： zuul.prefix = /api 。 另外， 对于代理前缀会默认从路径中移除，我们可以通过设置zuul.stripPrefix = false 来关闭该移除代理前缀的动作，也可以通过 zuul.routes. .strip-prefix = true 来对指定路由关闭移除代理前缀的动作。 注意， 在使用 zuul.prefix 参数的时候， 目前版本的实现还存在一些 Bug, 所以请谨慎使用， 或是避开会引发 Bug 的配置规则。 具体会引发 Bug 的规则如下 假设我们设置 zuul.prefix = /api, 当路由规则的 path 表达式以 /api 开头的时候，将会产生错误的映射关系.务必避免让路由表达式的起始字符串与 zuul.prefix 参数相同 本地跳转 在 Zuul 实现的 API 网关路由功能中， 还支持 forward 形式的服务端跳转配置。 实现方式非常简单，只需通过使用 path 与 url 的配置方式就能完成，通过 url 中使用 forward来指定需要跳转的服务器资源路径. zuul.routes.api-b.path=/api-b/** zuul.routes.api-b.url=forward:/local 当 API 网关接收到请求 /api-b/hello, 它符合 api-b 的路由规则，所以该请求会被 API 网关转发到网关的 /local/hello 请求上进行本地处理。 注意， 由于需要在 API 网关上实现本地跳转，所以相应的我们也需要为本地跳转实现对应的请求接口。 按照上面的例子， 在 API 网关上还需要增加 一 个/ local/hello的接口实现才能让 api-b 路由规则生效， 比如下面的实现。否则 Zuul 在进行 forward 转发的时候会因为找不到该请求而返回404错误。 @RestController public class HelloController { @RequestMapping (\"/local /hello\") public String hello() { return \"Hello World Local\"; } } Cookie和头信息 默认情况下， SpringCloud Zuul在请求路由时， 会过滤掉HTTP请求头信息中的一 些敏感 信 息， 防止它们被传 递到下游的外部服 务器。 默 认的 敏感 头 信 息 通 过zuul.sensitiveHeaders参数定义，包括Cookie、Set-Cookie、Authorization三个属性。 通过指定路由的参数来配置， 方法有下面两种。 ＃方法一：对指定路由开启自定义敏感头 zuul.routes..customSensitiveHeaders = true ＃方法二：将指定路由的敏感头设置为空 zuul.routes..sensitiveHeaders = 仅对指定的Web应用开启对敏感信息的传递，影响范围小， 不至于引起其他服务的信息泄露间题。 重定向问题 虽然可以通过网关访问登录页面并发起登录请求， 但是登录成功之后， 我们跳转到的页面URL却是具体Web应用实例的地址， 而不是通过网关的路由地址。 这个问题非常严重， 因为使用API网关的一个重要原因就是要将网关作为统一入口，从而不暴露所有的内部服务细节。 引起问题的大致原因是由于SpringSecurity或Shiro在登录完成之后，通过重定向的方式跳转到登录后的页面，此时登录后的请求结果状态码为302, 请求响应头信息中的 Location指向了具体的服务实例地址， 而请求头信息中的Host也指向了具体的服务实例 IP地址和端口。 所以，该问题的根本原因在于Spring Cloud Zuul在路由请求时，并没有将最初的Host信息设置正确。 过滤器详解 过滤器 Zuul包含了对请求的路由和过滤两个功能，其中路由功能负责将外部请求转发到具体的微服务实例上，是实现外 部访问统一入口的基础；而过滤器功能则负责对请求的处理过程进行干预，是实现请求校验、 服务聚合等功能的基础。 然而实际上，路由功能在真正运行时，它的路由映射和请求转发都是由几个不同的过滤器完成的。 其中，路由映射主要通过pre类型的过滤器完成，它将请求路径与配置的路由规则进行匹配，以找到需要转发的目标地址；而请求转发的部分则是由route类型的过滤器来完成，对pre类型过滤器获得的路由地址进行转发。 所以，过滤器可以说是Zuul实现API网关功能最为核心的部件，每 一 个进入Zuul的HTTP请求都会经过 一 系列的过滤器处理链得到请求响应并返回给客户端。 在Spring Cloud Zuul中实现的过滤器必须包含4个基本特征： 过滤类型、 执行顺序、执行条件、 具体操作 请求生命周期 核心过滤器 异常处理 SendErrorFilter 是用来处理异常信息 error.status_code 参数就是 SendErrorFilter 过滤器用来判断是否需要执行的重要参数 对于意外抛出的异常又会导致没有控制台输出也没有任何响应信息的情况出现,可以通过创建 一 个 error 类型的过滤器来捕获这些异常信息，并根据这些异常信息在请求上下文中注入需要返回给客户端的错误描述 禁用过滤器 不论是核心过滤器还是自定义过滤器， 只要在API网关应用中为它们创建了实例， 那么默认情况下， 它们都是启用状态的。 那么如果有些过滤器我们不想使用了， 如何禁用它们呢？大多情况下初识Zuul的使用者第 一 反应就是通过重写shouldFilter逻辑， 让它返回false, 这样该过滤器对于任何请求都不会被执行， 基本实现了对过滤器的禁用。 但是， 对于自定义过滤器来说似乎是实现了过滤器不生效的功能， 但是这样的做法缺乏灵活性。 由于直接要修改过旃器逻辑， 我们不得不重新编译程序， 并且如果该过滤器在未来一段时间还有可能被启用的时候， 那么就又得修改代码并编译程序。 同时， 对于核心过滤器来说， 就更为麻烦， 我们不得不获取源码来进行修改和编译。 Zuul中特别提供了一个参数来禁用指定的过滤器 zuul...disable = true 代表过滤器的类名， 比如快速入门示例中的AccessFilter;＜filterType>代表过滤器类型， 比如快速入门示例中 AccessFilter 的过滤器类型pre。 所以， 如果我们想要禁用快速入门示例中的 AccessFilter 过滤器， 只需要在application.properties 配置文件中增加如下配置即可： zuul.AccessFilter.pre.disable = true 该参数配置除了可以对自定义的过滤器进行禁用配置之外， 很多时候可以用它来禁用Spring Cloud Zuul中默认定义的核心过滤器。 这样我们就可以抛开Spring Cloud Zuul自带的那套核心过滤器， 实现 一 套更符合我们实际需求的处理机制。 动态加载 在微服务架构中， 由于API网关服务担负着外部访问统一入口的重任， 它同其他应用不同， 任何关闭应用和重启应用的操作都会使系统对外服务停止， 对于很多7 X 24小时服务的系统来说， 这样的情况是绝对不被允许的。 所以， 作为最外部的网关， 它必须具备动态更新内部逻辑的能力， 比如动态修改路由规则、 动态添加／删除过滤器等。 我们可以在不重启 API网关服务的前提下， 为其动态修改路由规则和添加或删除过滤器。 下面我们分别来看看如何通过Zuul来实现动态API网关服务。 动态路由 只需将API网关服务的配置文件通过Spring Cloud Config连接的Git仓库存储和管理， 我们就能轻松实现动态刷新路由规则的功能。 动态过滤器 By Dazzle Lin            updated 2019-07-02 22:53:03 "},"Chapter5/Spring Cloud Config.html":{"url":"Chapter5/Spring Cloud Config.html","title":"Spring Cloud Config","keywords":"","body":"Spring Cloud Config(分布式配置中心) 为分布式系统中的基础设施和微服务应用提供集中化的外部配置支持， 它分为服务端与客户端两个部分。 服务端也称为分布式配置中心， 它是一个独立的微服务应用， 用来连接配置仓库并为客户端提供获取配置信息、加密／解密信息等访问接口； 客户端则是微服务架构中的各个微服务应用或基础设施， 它们通过指定的配置中心来管理应用资源与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息。 Spring Cloud Config 实现了对服务端和客户端中环境变量和属性配置的抽象映射， 所以它除了适用于 Spring 构建的应用程序之外，也可以在任何其他语言运行的应用程序中使用。 Spring Cloud Config 实现的配置中心默认采用 Git 来存储配置信息， 所以使用 Spring Cloud Config 构建的配置服务器， 天然就支持对微服务应用配置信息的版本管理， 并且可以通过 Git 客户端工具来方便地管理和访问配置内容。 当然它也提供了对其他存储方式的支持。 快速入门 org.springframework.cloud spring-cloud-config-server org.springframework.cloud spring-cloud-starter-config org.springframework.boot spring-boot-starter-test test org.springframework.cloud spring-cloud-dependencies ${spring-cloud.version} pom import @SpringBootApplication @EnableConfigServer public class ConfigServerApplication { public static void main(String[] args) { SpringApplication.run(ConfigServerApplication.class, args); } } spring.application.name = config-server server.port=7001 spring.cloud.config.server.git.uri = https://github.com/linqinye/cloud-config.git spring.cloud.config.server.git.searchPaths = config-repo spring.cloud.config.server.git.username = linqinye spring.cloud.config.server.git.password = lin201542 其中 Git 的配置信息分别表示如下内容。 • spring.cloud.config.server.git.uri: 配置 Git 仓库位置。 • spring.cloud.config.server.git.searchPaths: 配置仓库路径下的相对搜索位置， 可以配置多个。 • spring.cloud.config.server.git.username: 访问 Git 仓库的用户名。 • spring.cloud.config.server.git.password: 访问 Git 仓库的用户密码。 配置规则详解 访问配置信息的URL与配置文件的映射关系如下所示： • /{application}/{profile} [/{label}] • /{application}-{profile}. yml • /{label}/{application}-{profile}.yml • /{application}-{profile}.properties • /{label}/{application}-{profile}.properties url会映射 {application}-{profile} .properties 对应的配置文件，其中 {label} 对应Git上不同的分支，默认master 。我们可以尝试构造不同的 url 来访问不同的配置内容， 比如， 要访问 config-label-test分支，didispace应用的 prod环境， 就可以访问这个 url: http://localhost:7001/didispace/prod/config-label-test { \"name\": \"didispace\", \"profiles\": [ \"prod\" ], \"label\": \"config-label-test\", \"version\": \"b2369e3cf49036896d15be8292764a508b7eb322\", \"state\": null, \"propertySources\": [ { \"name\": \"https://github.com/linqinye/cloud-config.git/config-repo/didispace-prod.properties\", \"source\": { \"from\": \"git-prod-2.0\" } }, { \"name\": \"https://github.com/linqinye/cloud-config.git/config-repo/didispace.properties\", \"source\": { \"from\": \"git-default-2.0\" } } ] } 该JSON中返回了应用名 didispace, 环境名 prod, 分支名 config-label-test,以及 default 环境和 prod 环境的配置内容。 另外， 之前没有提到过的 version, 从下图我们可以观察到， 它对应的是在 Git 上的 commit 号。 同时， 我们可以看到 config-server 的控制台中还输出了下面的内容，配置服务器在从 Git 中获取配置信息后， 会存储一份在 config-server 的文件系统中， 实质上config-server 是通过 git clone 命令将配置内容复制了一份在本地存储， 然后读取这些内容并返回给微服务应用进行加载。 config-server 通过 Git 在本地仓库暂存，可以有效防止当 Git 仓库出现故障而引起无法加载配置信息的情况。 我们可以通过断开网络， 再次发起http://localhost:7001/didispace/prod/config-label-test请求，在控制台中可输出 config-server 提示无法从远程获取该分支内容的报错信息： Could not pull remote for config-label-test, 但是它依然会为该请求返回配置内容， 这些内容源于之前访问时存于 config-server 本地文件系统中的配置内容。 客户端配置映射 创建项目 创建 bootstrap.properties 配置， 来指定获取配置文件的 config-server位置 spring.application.name = didispace spring.cloud.config.profile=dev spring.cloud.config.label=master spring.cloud.config.uri=http://localhost:7001/ server.port=7002 上述配置参数与 Git 中存储的配置文件中各个部分的对应关系如下所示。 • spring.application.name: 对应配置文件规则中的 {application} 部分。 • spring.cloud.config.profile: 对应配置文件规则中的 {profile} 部分。 • spring.cloud.config.label: 对应配置文件规则中的 {label} 部分。 • spring.cloud.config.uri: 配置中心 config-server 的地址。 注意 上面这些属性必须配置在 bootstrap.properties 中， 这样config-server 中的配置信息才能被正确加载。在第 2 章中，我们详细说明了 Spring Boot对配置文件的加载顺序， 对于本应用 jar 包之外的配置文件加载会优先于应用 jar 包内的配置内容， 而通过 bootstrap.properties 对 config-server 的配置， 使得该应用会从 config-server 中获取 一 些外部配置信息， 这些信息的优先级比本地的内容要高， 从而实现了外部化配置。 千万不要引入 org.springframework.cloud spring-cloud-config-server 只需要引入 org.springframework.boot spring-boot-starter-web org.springframework.cloud spring-cloud-starter-config 创建一个 RESTful 接口来返回配置中心的 from 属性， 通过 @Value(\"${from}\")绑定配置服务中配置的 from 属性 @RefreshScope @RestController public class TestController { @Value(\"${from}\") private String from; @RequestMapping(\"/from\") public String from(){ return this.from; } } 除了通过@Value注解绑定注入之外， 也可以通过Environment对象来获取配置属性 @RefreshScope @RestController public class TestController { @Autowired private Environment environment; @RequestMapping(\"/from\") public String from(){ return environment.getProperty(\"from\",\"underfined\"); } } 启动config-client应用， 并访问http://localhost:7002/from, 我们就可以根据配置内容输出对应环境的from内容了。根据当前配置，我们可以获得如下返回内容：git-dev-1.0。 可以继续通过修改bootstrap.properties中的配置内容获取不同的配置信息来熟悉配置服务中的配置规则。 服务端详解 占位符配置URI {application}、{profile}、{label}这些占位符除了用于标识配置文件的规则之外， 还可以用于ConfigServer 中对 Git 仓库地址的URI配置。 比如， 我们可以通过{application}占位符来实现 一 个应用对应一个Git仓库目录的配置效果. spring.cloud.config.server.git.uri = https://github.com/linqinye/cloud-config.git/{application} spring.cloud.config.server.git.username = linqinye spring.cloud.config.server.git.password = lin201542 {application}代表了应用名， 所以当客户端应用向ConfigServer发起获取配置的请求时，ConfigServer会根据客户端的spring.application.name 信息来填充{application}占位符以定位配置资源的存储位置， 从而实现根据微服务应用的属性动态获取不同位置的配置。 在这些占位符中， {label}参数较为特别 ， 如果Git的分支和标签名包含\"/\", 那么{label}参数在HTTP的URL中应该使用 \"(_)\" 来替代， 以避免改变了URI含义， 指向到其他的URI资源 本地仓库 文件都会在ConfigServer的本地文件系统中存储一份，这些文件默认会被存储于以config-repo为前缀的临时目录中， 比如名为/tmp/config-repo- 健康监测 spring.cloud.config.server.git.uri=http://git.oschina.net/didispace/{applicatio n}-config spring.cloud.config.server.git.username = username spring.cloud.config.server.git.username = password spring.cloud.config.server.health.repositories.check.name = check-repo spring.cloud.config.server.health.repositories.check.label = master spring.cloud.config.server.health.repositories.check.profiles = default 由千健康检测的 repositories 是个 Map 对象，所以实际使用时我们可以配置多个。 而每个配置中包含了与定位仓库地址时类似的三个元素。 • name: 应用名。 • label: 分支名。 • profiles: 环境名 通过使用 spring.cloud.config.server.health.enabled=false 参数设置来关闭 属性覆盖 只需要通过 spring.cloud.config.server.overrides 属性来设置键值对的参数，这些参数会以 Map 的方式加载到客户端的配置中 spring.cloud.config.server.overrides.name = didi spring.cloud.config.server.overrides.from = shanghai 通过该属性配置的参数，不会被 Spring Cloud 的客户端修改，并且 Spring Cloud 客户端从 Config Server 中获取配置信息时，都会取得这些配置信息。 利用该特性可以方便地为Spring Cloud 应用配置 一 些共同属性或是默认属性 安全保护 基于Spring boot,结合Spring Security pom.xml添加依赖 org.springframework.boot spring-boot-starter-security 默认情况下，我们可以获得 一 个名为 user 的用户，并且在配置中心启动的时候，在日志中打印出该用户的随机密码. 大多数情况下，我们并不会使用随机生成密码的机制。 我们可以在配置文件中指定用户和密码 security.user.name=user security.user.password=37cc5635-559b-4e6f-b633-7e932b813f73 由于我们已经为 config-server 设置了安全保护，如果这时候连接到配置中心的客户端中没有设置对应的安全信息，在获取配置信息时会返回401错误。 所以，需要通过配置的方式在客户端中加入安全信息来通过校验 spring.cloud.config.username=user spring.cloud.config.password=37cc5635-559b-4e6f-b633-7e932b813f73 加密解密 如果我们直接将敏感信息以明文的方式存储于微服务应用的配置文件中是非常危险的。针对这个问题， Spring Cloud Config 提供了对属性进行加密解密的功能，以保护配置文件中的信息安全。 spring.datasource.username = didi spring.datasource.password={cipher}dba6505baa8ld78bd08799d8d4429de499bd4c2053c0 5f029e7cfbf143695f5b 在 Spring Cloud Config 中通过在属性值前使用 {cipher} 前缀来标注该内容是一个加密值，当微服务客户端加载配置时，配置中心会自动为带有 {cipher} 前缀的值进行解密。通过该机制的实现，运维团队就可以放心地将线上信息的加密资源给到微服务团队，而不用担心这些敏感信息遭到泄露了。 前提 在使用 Spring Cloud Config 的加密解密功能时，有 一 个必要的前提需要我们注意。 为了启用该功能， 我们需要在配置中心的运行环境中安装不限长度的 JCE 版本 (UnlimitedStrength Java Cryptography Extension) 。 虽然， JCE 功能在JRE中自带，但是默认使用的是有长度限制的版本。 我们可以从Oracle的官方网站下载到它，它是 一 个压缩包，解压后可以看到下面三个文件 README. txt local_policy.jar US_export_policy.jar 将 localpolicy. jar 和 US export-policy. jar 两个文件复制到$JAVA HOME/jre/lib/security 目录下， 覆盖原来的默认内容。 到这里， 加密解密的准备工作就完成了。 服务端详解 服务化配置中心 服务端配置 org.springframework.cloud spring-cloud-starter-netflix-eureka-server application.properties spring.application.name = config-server server.port=7001 eureka.client.serviceUrl.defaultZone=http://127.0.0.1:11112/eureka/ spring.cloud.config.server.git.uri = https://github.com/linqinye/cloud-config.git spring.cloud.config.server.git.searchPaths = config-repo spring.cloud.config.server.git.username = linqinye spring.cloud.config.server.git.password = lin201542 @EnableDiscoveryClient 客户端配置 org.springframework.cloud spring-cloud-starter-netflix-eureka-server bootstrap.properties spring.application.name=didispace server.port=7002 eureka.client.serviceUrl.defaultZone=http://127.0.0.1:11112/eureka/ spring.cloud.config.profile=dev spring.cloud.config.discovery.enabled=true spring.cloud.config.discovery.serviceId=config-server @EnableDiscoveryClient 失败快速响应与重试 快速响应 要实现客户端优先判断ConfigServer获取是否正常， 并快速响应失败内容， 只需在bootstrap.properties中配置参数spring.cloud.config.failFast= true即可 自动重试 上述基础上进行,在客户端的 pom.xml 中增加 spring-retry 和 spring-boot-starter-aop依赖 org.springframework.retry spring-retry org.springframework.boot spring-boot-starter-aop 不需要再做其他任何配置， 启动客户端应用， 在控制台中可以看到如下内容。 客户端在连接 Config Server 失败之后， 会继续尝试， 直到第 6 次失败后， 才返回错误信息。 通过这样的重试机制， 可以避免 一 些间歇性问题引起的失败导致客户端应用无法启动的情况。 若对默认的最大重试次数和重试间隔等设置不满意，还可以通过下面的参数进行调整 spring.cloud.config.retry.multiplier: 初始重试间隔时间（单位为毫秒），默认为 1000 毫秒。 spring.cloud.config.retry.initial-interval: 下 一 间隔的乘数，默认为 1.1, 所以当最初间隔是 1000 毫秒时， 下 一 次失败后的间隔为 1100 毫秒。 spring.cloud.config.retry.max-interval: 最大间隔时间，默认为 2000毫秒。 spring.cloud.config.retry.max-attempts: 最大重试次数，默认为 6 次。 动态刷新配置 在config-client的pom.xml中新增spring-boot-starter-actuator监控模块。 其中包含了/refresh端点的实现，该端点将用于实现客户端应用配置信息的重新获取与刷新 org.springframework.boot spring-boot-starter-actuator 需要在配置的页面加上，就是说附带@Value的页面加上@RefreshScope 注意：config-server和config-client的配置都得加上 management.endpoints.web.exposure.include=bus-refresh（只暴露bus-refresh节点） 重新启动config-client ， 访问一次http://localhost:7002/frorn, 可以看到当前的配置值。 修改Git仓库config-repo/didispace-dev.properties文件中from的值。 再访问一次http://localhost7002/frorn, 可以看到配置值没有改变。 通过POST请求发送到请求刷新的页面http://localhost:7002/actuator/bus-refresh刷新配置 再访问一次http://localhost7002/from, 可以看到配置值已经是更新后的值 By Dazzle Lin            updated 2019-07-02 22:56:45 "},"Chapter5/Spring Cloud Bus.html":{"url":"Chapter5/Spring Cloud Bus.html","title":"Spring Cloud Bus","keywords":"","body":"Spring Cloud Bus(消息总线) RabbitMQ基础概念 Broker: 可以理解为消息队列服务器的实体， 它是一个中间件应用， 负责接收消息生产者的消息， 然后将消息发送至消息接收者或者其他的Broker。 Exchange: 消息交换机，是消息第一个到达的地方，消息通过它指定的路由规则，分发到不同的消息队列中去。 Queue: 消息队列， 消息通过发送和路由之后最终到达的地方， 到达Queue的消息即进入逻辑上等待消费的状态。 每个消息都会被发送到一个或多个队列 。 Binding: 绑定，它的作用就是把Exchange和Queue按照路由规则绑定起来， 也就是Exchange和Queue之间的虚拟连接 。 Routing Key: 路由关键字，Exchange根据这个关键字进行消息投递。 Virtual host: 虚拟主机， 它是对Broker的虚拟划分， 将消费者、 生产者和它们依赖的AMQP相关结构进行隔离，一般都是为了安全考虚。比如，我们可以在一个Broker中设置多个虚拟主机， 对不同用户进行权限的分离 。 Connection: 连接， 代表生产者、 消费者、 Broker之间进行通信的物理网络。 Channel: 消息通道，用千连接生产者和消费者的逻辑结构 。在客户端的每个连接里，可建立多个Channel, 每个Channel代表一个会话任务， 通过Channel可以隔离同一连接中的不同交互内容。 Producer: 消息生产者， 制造消息并发送消息的程序。 Consumer: 消息消费者， 接收消息并处理消息的程序 在ConfigServer中也引入SpringCloud Bus, 将配置服务端也加入到消息总线中来。 /actuator/bus-refresh请求不再发送到具体服务实例上， 而是发送给Config Server, 并通过destination参数来指定需要更新配置的服务或实例。通过上面的改动，我们的服务实例不需要再承担触发配置更新的职责。 同时，对于Git的触发等配置都只需要针对ConfigServer即可， 从而简化了集群上的 一 些维护工作。 By Dazzle Lin            updated 2019-07-02 22:57:24 "}}